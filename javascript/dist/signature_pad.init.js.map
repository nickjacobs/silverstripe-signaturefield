{"mappings":"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","sources":["javascript/src/signature_pad.init.js","node_modules/signature_pad/dist/signature_pad.js","node_modules/signature_pad/src/point.ts","node_modules/signature_pad/src/bezier.ts","node_modules/signature_pad/src/signature_event_target.ts","node_modules/signature_pad/src/throttle.ts","node_modules/signature_pad/src/signature_pad.ts"],"sourcesContent":["import SignaturePad from \"signature_pad\";\n\njQuery.entwine(\"signature\", function($) {\n\n\t$(\"input.signature.no-sigpad\").entwine({\n\t\tonmatch: function() {\n\t\t\tvar $input = this; // = jquery object\n            var $canvas = $('<canvas class=\"signature-canvas\"></canvas>');\n\t\t\t// insert canvas & create pad\n\t\t\t$input.after($canvas);\n\n            // Dynamically set the canvas width to match its parent\n            function syncCanvasSize() {\n                const canvas = $canvas[0];\n                const rect = canvas.getBoundingClientRect();\n                canvas.width = rect.width;\n                canvas.height = rect.height;\n            }\n\n            const pollCanvasVisible = setInterval(() => {\n                if ($canvas.is(':visible')) {\n                    syncCanvasSize();\n                    clearInterval(pollCanvasVisible);\n                }\n            }, 100);\n\n            $(window).on('resize', syncCanvasSize);\n            $input.on('focus', syncCanvasSize);\n\n            var signaturePad = new SignaturePad($canvas[0]);\n\t\t\tif(this.val()!=''){\n\t\t\t\tsignaturePad.fromDataURL(this.val());\n\t\t\t}\n\t\t\tsignaturePad.addEventListener(\"endStroke\",() => {\n                $input.val( signaturePad.toDataURL() );\n            });\n\t\t\t// add clear button\n\t\t\tvar $clearbtn = $('<div class=\"signaturefield-clear-btn\"><span>Clear</span></div>');\n\t\t\t$clearbtn.click(function(event){\n\t\t\t\tsignaturePad.clear();\n\t\t\t\t$input.val('');\n\t\t\t});\n\t\t\t// insert button\n\t\t\t$canvas.after($clearbtn);\n\n\t\t\t// Monkey patch to expose svg data (http://me.dt.in.th/page/JavaScript-override/)\n\t\t\t// https://github.com/szimek/signature_pad/issues/44\n//\t\t\tvar originalSaveResults = test.saveResults\n//\t\t\ttest.saveResults = function(filepath) {\n//\t\t\t\tvar returnValue = originalSaveResults.apply(this, arguments)\n//\t\t\t\tvar planpath = filepath.replace('.xml', '_plan.xml')\n//\t\t\t\tconsole.log('Save test plan to ' + planpath)\n//\t\t\t\treturn returnValue\n//\t\t\t}\n\n//\t\t\t// Returns signature image as data URL\n//\t\t\tsignaturePad.toDataURL();\n//\n//\t\t\t// Draws signature image from data URL\n//\t\t\tsignaturePad.fromDataURL(\"data:image/png;base64,iVBORw0K...\");\n//\n//\t\t\t// Clears the canvas\n//\t\t\tsignaturePad.clear();\n//\n//\t\t\t// Returns true if canvas is empty, otherwise returns false\n//\t\t\tsignaturePad.isEmpty();\n//\n//\t\t\t// Unbinds all event handlers (onunmatch?)\n//\t\t\tsignaturePad.off();\n\t\t},\n\n\t});\n});\n\n","/*!\n * Signature Pad v4.1.4 | https://github.com/szimek/signature_pad\n * (c) 2022 Szymon Nowak | Released under the MIT license\n */\n\nclass Point {\n    constructor(x, y, pressure, time) {\n        if (isNaN(x) || isNaN(y)) {\n            throw new Error(`Point is invalid: (${x}, ${y})`);\n        }\n        this.x = +x;\n        this.y = +y;\n        this.pressure = pressure || 0;\n        this.time = time || Date.now();\n    }\n    distanceTo(start) {\n        return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n    }\n    equals(other) {\n        return (this.x === other.x &&\n            this.y === other.y &&\n            this.pressure === other.pressure &&\n            this.time === other.time);\n    }\n    velocityFrom(start) {\n        return this.time !== start.time\n            ? this.distanceTo(start) / (this.time - start.time)\n            : 0;\n    }\n}\n\nclass Bezier {\n    constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n        this.startPoint = startPoint;\n        this.control2 = control2;\n        this.control1 = control1;\n        this.endPoint = endPoint;\n        this.startWidth = startWidth;\n        this.endWidth = endWidth;\n    }\n    static fromPoints(points, widths) {\n        const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n        const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n        return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n    }\n    static calculateControlPoints(s1, s2, s3) {\n        const dx1 = s1.x - s2.x;\n        const dy1 = s1.y - s2.y;\n        const dx2 = s2.x - s3.x;\n        const dy2 = s2.y - s3.y;\n        const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n        const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n        const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n        const dxm = m1.x - m2.x;\n        const dym = m1.y - m2.y;\n        const k = l2 / (l1 + l2);\n        const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n        const tx = s2.x - cm.x;\n        const ty = s2.y - cm.y;\n        return {\n            c1: new Point(m1.x + tx, m1.y + ty),\n            c2: new Point(m2.x + tx, m2.y + ty),\n        };\n    }\n    length() {\n        const steps = 10;\n        let length = 0;\n        let px;\n        let py;\n        for (let i = 0; i <= steps; i += 1) {\n            const t = i / steps;\n            const cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n            const cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n            if (i > 0) {\n                const xdiff = cx - px;\n                const ydiff = cy - py;\n                length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n            }\n            px = cx;\n            py = cy;\n        }\n        return length;\n    }\n    point(t, start, c1, c2, end) {\n        return (start * (1.0 - t) * (1.0 - t) * (1.0 - t))\n            + (3.0 * c1 * (1.0 - t) * (1.0 - t) * t)\n            + (3.0 * c2 * (1.0 - t) * t * t)\n            + (end * t * t * t);\n    }\n}\n\nclass SignatureEventTarget {\n    constructor() {\n        try {\n            this._et = new EventTarget();\n        }\n        catch (error) {\n            this._et = document;\n        }\n    }\n    addEventListener(type, listener, options) {\n        this._et.addEventListener(type, listener, options);\n    }\n    dispatchEvent(event) {\n        return this._et.dispatchEvent(event);\n    }\n    removeEventListener(type, callback, options) {\n        this._et.removeEventListener(type, callback, options);\n    }\n}\n\nfunction throttle(fn, wait = 250) {\n    let previous = 0;\n    let timeout = null;\n    let result;\n    let storedContext;\n    let storedArgs;\n    const later = () => {\n        previous = Date.now();\n        timeout = null;\n        result = fn.apply(storedContext, storedArgs);\n        if (!timeout) {\n            storedContext = null;\n            storedArgs = [];\n        }\n    };\n    return function wrapper(...args) {\n        const now = Date.now();\n        const remaining = wait - (now - previous);\n        storedContext = this;\n        storedArgs = args;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            result = fn.apply(storedContext, storedArgs);\n            if (!timeout) {\n                storedContext = null;\n                storedArgs = [];\n            }\n        }\n        else if (!timeout) {\n            timeout = window.setTimeout(later, remaining);\n        }\n        return result;\n    };\n}\n\nclass SignaturePad extends SignatureEventTarget {\n    constructor(canvas, options = {}) {\n        super();\n        this.canvas = canvas;\n        this._handleMouseDown = (event) => {\n            if (event.buttons === 1) {\n                this._drawningStroke = true;\n                this._strokeBegin(event);\n            }\n        };\n        this._handleMouseMove = (event) => {\n            if (this._drawningStroke) {\n                this._strokeMoveUpdate(event);\n            }\n        };\n        this._handleMouseUp = (event) => {\n            if (event.buttons === 1 && this._drawningStroke) {\n                this._drawningStroke = false;\n                this._strokeEnd(event);\n            }\n        };\n        this._handleTouchStart = (event) => {\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            if (event.targetTouches.length === 1) {\n                const touch = event.changedTouches[0];\n                this._strokeBegin(touch);\n            }\n        };\n        this._handleTouchMove = (event) => {\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            const touch = event.targetTouches[0];\n            this._strokeMoveUpdate(touch);\n        };\n        this._handleTouchEnd = (event) => {\n            const wasCanvasTouched = event.target === this.canvas;\n            if (wasCanvasTouched) {\n                if (event.cancelable) {\n                    event.preventDefault();\n                }\n                const touch = event.changedTouches[0];\n                this._strokeEnd(touch);\n            }\n        };\n        this._handlePointerStart = (event) => {\n            this._drawningStroke = true;\n            event.preventDefault();\n            this._strokeBegin(event);\n        };\n        this._handlePointerMove = (event) => {\n            if (this._drawningStroke) {\n                event.preventDefault();\n                this._strokeMoveUpdate(event);\n            }\n        };\n        this._handlePointerEnd = (event) => {\n            if (this._drawningStroke) {\n                event.preventDefault();\n                this._drawningStroke = false;\n                this._strokeEnd(event);\n            }\n        };\n        this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n        this.minWidth = options.minWidth || 0.5;\n        this.maxWidth = options.maxWidth || 2.5;\n        this.throttle = ('throttle' in options ? options.throttle : 16);\n        this.minDistance = ('minDistance' in options ? options.minDistance : 5);\n        this.dotSize = options.dotSize || 0;\n        this.penColor = options.penColor || 'black';\n        this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n        this._strokeMoveUpdate = this.throttle\n            ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)\n            : SignaturePad.prototype._strokeUpdate;\n        this._ctx = canvas.getContext('2d');\n        this.clear();\n        this.on();\n    }\n    clear() {\n        const { _ctx: ctx, canvas } = this;\n        ctx.fillStyle = this.backgroundColor;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        this._data = [];\n        this._reset(this._getPointGroupOptions());\n        this._isEmpty = true;\n    }\n    fromDataURL(dataUrl, options = {}) {\n        return new Promise((resolve, reject) => {\n            const image = new Image();\n            const ratio = options.ratio || window.devicePixelRatio || 1;\n            const width = options.width || this.canvas.width / ratio;\n            const height = options.height || this.canvas.height / ratio;\n            const xOffset = options.xOffset || 0;\n            const yOffset = options.yOffset || 0;\n            this._reset(this._getPointGroupOptions());\n            image.onload = () => {\n                this._ctx.drawImage(image, xOffset, yOffset, width, height);\n                resolve();\n            };\n            image.onerror = (error) => {\n                reject(error);\n            };\n            image.crossOrigin = 'anonymous';\n            image.src = dataUrl;\n            this._isEmpty = false;\n        });\n    }\n    toDataURL(type = 'image/png', encoderOptions) {\n        switch (type) {\n            case 'image/svg+xml':\n                if (typeof encoderOptions !== 'object') {\n                    encoderOptions = undefined;\n                }\n                return `data:image/svg+xml;base64,${btoa(this.toSVG(encoderOptions))}`;\n            default:\n                if (typeof encoderOptions !== 'number') {\n                    encoderOptions = undefined;\n                }\n                return this.canvas.toDataURL(type, encoderOptions);\n        }\n    }\n    on() {\n        this.canvas.style.touchAction = 'none';\n        this.canvas.style.msTouchAction = 'none';\n        this.canvas.style.userSelect = 'none';\n        const isIOS = /Macintosh/.test(navigator.userAgent) && 'ontouchstart' in document;\n        if (window.PointerEvent && !isIOS) {\n            this._handlePointerEvents();\n        }\n        else {\n            this._handleMouseEvents();\n            if ('ontouchstart' in window) {\n                this._handleTouchEvents();\n            }\n        }\n    }\n    off() {\n        this.canvas.style.touchAction = 'auto';\n        this.canvas.style.msTouchAction = 'auto';\n        this.canvas.style.userSelect = 'auto';\n        this.canvas.removeEventListener('pointerdown', this._handlePointerStart);\n        this.canvas.removeEventListener('pointermove', this._handlePointerMove);\n        this.canvas.ownerDocument.removeEventListener('pointerup', this._handlePointerEnd);\n        this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n        this.canvas.removeEventListener('mousemove', this._handleMouseMove);\n        this.canvas.ownerDocument.removeEventListener('mouseup', this._handleMouseUp);\n        this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n        this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n        this.canvas.removeEventListener('touchend', this._handleTouchEnd);\n    }\n    isEmpty() {\n        return this._isEmpty;\n    }\n    fromData(pointGroups, { clear = true } = {}) {\n        if (clear) {\n            this.clear();\n        }\n        this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));\n        this._data = this._data.concat(pointGroups);\n    }\n    toData() {\n        return this._data;\n    }\n    _getPointGroupOptions(group) {\n        return {\n            penColor: group && 'penColor' in group ? group.penColor : this.penColor,\n            dotSize: group && 'dotSize' in group ? group.dotSize : this.dotSize,\n            minWidth: group && 'minWidth' in group ? group.minWidth : this.minWidth,\n            maxWidth: group && 'maxWidth' in group ? group.maxWidth : this.maxWidth,\n            velocityFilterWeight: group && 'velocityFilterWeight' in group\n                ? group.velocityFilterWeight\n                : this.velocityFilterWeight,\n        };\n    }\n    _strokeBegin(event) {\n        this.dispatchEvent(new CustomEvent('beginStroke', { detail: event }));\n        const pointGroupOptions = this._getPointGroupOptions();\n        const newPointGroup = Object.assign(Object.assign({}, pointGroupOptions), { points: [] });\n        this._data.push(newPointGroup);\n        this._reset(pointGroupOptions);\n        this._strokeUpdate(event);\n    }\n    _strokeUpdate(event) {\n        if (this._data.length === 0) {\n            this._strokeBegin(event);\n            return;\n        }\n        this.dispatchEvent(new CustomEvent('beforeUpdateStroke', { detail: event }));\n        const x = event.clientX;\n        const y = event.clientY;\n        const pressure = event.pressure !== undefined\n            ? event.pressure\n            : event.force !== undefined\n                ? event.force\n                : 0;\n        const point = this._createPoint(x, y, pressure);\n        const lastPointGroup = this._data[this._data.length - 1];\n        const lastPoints = lastPointGroup.points;\n        const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n        const isLastPointTooClose = lastPoint\n            ? point.distanceTo(lastPoint) <= this.minDistance\n            : false;\n        const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);\n        if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n            const curve = this._addPoint(point, pointGroupOptions);\n            if (!lastPoint) {\n                this._drawDot(point, pointGroupOptions);\n            }\n            else if (curve) {\n                this._drawCurve(curve, pointGroupOptions);\n            }\n            lastPoints.push({\n                time: point.time,\n                x: point.x,\n                y: point.y,\n                pressure: point.pressure,\n            });\n        }\n        this.dispatchEvent(new CustomEvent('afterUpdateStroke', { detail: event }));\n    }\n    _strokeEnd(event) {\n        this._strokeUpdate(event);\n        this.dispatchEvent(new CustomEvent('endStroke', { detail: event }));\n    }\n    _handlePointerEvents() {\n        this._drawningStroke = false;\n        this.canvas.addEventListener('pointerdown', this._handlePointerStart);\n        this.canvas.addEventListener('pointermove', this._handlePointerMove);\n        this.canvas.ownerDocument.addEventListener('pointerup', this._handlePointerEnd);\n    }\n    _handleMouseEvents() {\n        this._drawningStroke = false;\n        this.canvas.addEventListener('mousedown', this._handleMouseDown);\n        this.canvas.addEventListener('mousemove', this._handleMouseMove);\n        this.canvas.ownerDocument.addEventListener('mouseup', this._handleMouseUp);\n    }\n    _handleTouchEvents() {\n        this.canvas.addEventListener('touchstart', this._handleTouchStart);\n        this.canvas.addEventListener('touchmove', this._handleTouchMove);\n        this.canvas.addEventListener('touchend', this._handleTouchEnd);\n    }\n    _reset(options) {\n        this._lastPoints = [];\n        this._lastVelocity = 0;\n        this._lastWidth = (options.minWidth + options.maxWidth) / 2;\n        this._ctx.fillStyle = options.penColor;\n    }\n    _createPoint(x, y, pressure) {\n        const rect = this.canvas.getBoundingClientRect();\n        return new Point(x - rect.left, y - rect.top, pressure, new Date().getTime());\n    }\n    _addPoint(point, options) {\n        const { _lastPoints } = this;\n        _lastPoints.push(point);\n        if (_lastPoints.length > 2) {\n            if (_lastPoints.length === 3) {\n                _lastPoints.unshift(_lastPoints[0]);\n            }\n            const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], options);\n            const curve = Bezier.fromPoints(_lastPoints, widths);\n            _lastPoints.shift();\n            return curve;\n        }\n        return null;\n    }\n    _calculateCurveWidths(startPoint, endPoint, options) {\n        const velocity = options.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n            (1 - options.velocityFilterWeight) * this._lastVelocity;\n        const newWidth = this._strokeWidth(velocity, options);\n        const widths = {\n            end: newWidth,\n            start: this._lastWidth,\n        };\n        this._lastVelocity = velocity;\n        this._lastWidth = newWidth;\n        return widths;\n    }\n    _strokeWidth(velocity, options) {\n        return Math.max(options.maxWidth / (velocity + 1), options.minWidth);\n    }\n    _drawCurveSegment(x, y, width) {\n        const ctx = this._ctx;\n        ctx.moveTo(x, y);\n        ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n        this._isEmpty = false;\n    }\n    _drawCurve(curve, options) {\n        const ctx = this._ctx;\n        const widthDelta = curve.endWidth - curve.startWidth;\n        const drawSteps = Math.ceil(curve.length()) * 2;\n        ctx.beginPath();\n        ctx.fillStyle = options.penColor;\n        for (let i = 0; i < drawSteps; i += 1) {\n            const t = i / drawSteps;\n            const tt = t * t;\n            const ttt = tt * t;\n            const u = 1 - t;\n            const uu = u * u;\n            const uuu = uu * u;\n            let x = uuu * curve.startPoint.x;\n            x += 3 * uu * t * curve.control1.x;\n            x += 3 * u * tt * curve.control2.x;\n            x += ttt * curve.endPoint.x;\n            let y = uuu * curve.startPoint.y;\n            y += 3 * uu * t * curve.control1.y;\n            y += 3 * u * tt * curve.control2.y;\n            y += ttt * curve.endPoint.y;\n            const width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);\n            this._drawCurveSegment(x, y, width);\n        }\n        ctx.closePath();\n        ctx.fill();\n    }\n    _drawDot(point, options) {\n        const ctx = this._ctx;\n        const width = options.dotSize > 0\n            ? options.dotSize\n            : (options.minWidth + options.maxWidth) / 2;\n        ctx.beginPath();\n        this._drawCurveSegment(point.x, point.y, width);\n        ctx.closePath();\n        ctx.fillStyle = options.penColor;\n        ctx.fill();\n    }\n    _fromData(pointGroups, drawCurve, drawDot) {\n        for (const group of pointGroups) {\n            const { points } = group;\n            const pointGroupOptions = this._getPointGroupOptions(group);\n            if (points.length > 1) {\n                for (let j = 0; j < points.length; j += 1) {\n                    const basicPoint = points[j];\n                    const point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);\n                    if (j === 0) {\n                        this._reset(pointGroupOptions);\n                    }\n                    const curve = this._addPoint(point, pointGroupOptions);\n                    if (curve) {\n                        drawCurve(curve, pointGroupOptions);\n                    }\n                }\n            }\n            else {\n                this._reset(pointGroupOptions);\n                drawDot(points[0], pointGroupOptions);\n            }\n        }\n    }\n    toSVG({ includeBackgroundColor = false } = {}) {\n        const pointGroups = this._data;\n        const ratio = Math.max(window.devicePixelRatio || 1, 1);\n        const minX = 0;\n        const minY = 0;\n        const maxX = this.canvas.width / ratio;\n        const maxY = this.canvas.height / ratio;\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n        svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n        svg.setAttribute('viewBox', `${minX} ${minY} ${maxX} ${maxY}`);\n        svg.setAttribute('width', maxX.toString());\n        svg.setAttribute('height', maxY.toString());\n        if (includeBackgroundColor && this.backgroundColor) {\n            const rect = document.createElement('rect');\n            rect.setAttribute('width', '100%');\n            rect.setAttribute('height', '100%');\n            rect.setAttribute('fill', this.backgroundColor);\n            svg.appendChild(rect);\n        }\n        this._fromData(pointGroups, (curve, { penColor }) => {\n            const path = document.createElement('path');\n            if (!isNaN(curve.control1.x) &&\n                !isNaN(curve.control1.y) &&\n                !isNaN(curve.control2.x) &&\n                !isNaN(curve.control2.y)) {\n                const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} ` +\n                    `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +\n                    `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +\n                    `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n                path.setAttribute('d', attr);\n                path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n                path.setAttribute('stroke', penColor);\n                path.setAttribute('fill', 'none');\n                path.setAttribute('stroke-linecap', 'round');\n                svg.appendChild(path);\n            }\n        }, (point, { penColor, dotSize, minWidth, maxWidth }) => {\n            const circle = document.createElement('circle');\n            const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;\n            circle.setAttribute('r', size.toString());\n            circle.setAttribute('cx', point.x.toString());\n            circle.setAttribute('cy', point.y.toString());\n            circle.setAttribute('fill', penColor);\n            svg.appendChild(circle);\n        });\n        return svg.outerHTML;\n    }\n}\n\nexport { SignaturePad as default };\n//# sourceMappingURL=signature_pad.js.map\n","// Interface for point data structure used e.g. in SignaturePad#fromData method\nexport interface BasicPoint {\n  x: number;\n  y: number;\n  pressure: number;\n  time: number;\n}\n\nexport class Point implements BasicPoint {\n  public x: number;\n  public y: number;\n  public pressure: number;\n  public time: number;\n\n  constructor(x: number, y: number, pressure?: number, time?: number) {\n    if (isNaN(x) || isNaN(y)) {\n      throw new Error(`Point is invalid: (${x}, ${y})`);\n    }\n    this.x = +x;\n    this.y = +y;\n    this.pressure = pressure || 0;\n    this.time = time || Date.now();\n  }\n\n  public distanceTo(start: BasicPoint): number {\n    return Math.sqrt(\n      Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2),\n    );\n  }\n\n  public equals(other: BasicPoint): boolean {\n    return (\n      this.x === other.x &&\n      this.y === other.y &&\n      this.pressure === other.pressure &&\n      this.time === other.time\n    );\n  }\n\n  public velocityFrom(start: BasicPoint): number {\n    return this.time !== start.time\n      ? this.distanceTo(start) / (this.time - start.time)\n      : 0;\n  }\n}\n","import { BasicPoint, Point } from './point';\n\nexport class Bezier {\n  public static fromPoints(\n    points: Point[],\n    widths: { start: number; end: number },\n  ): Bezier {\n    const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n    const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n\n    return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n  }\n\n  private static calculateControlPoints(\n    s1: BasicPoint,\n    s2: BasicPoint,\n    s3: BasicPoint,\n  ): {\n    c1: BasicPoint;\n    c2: BasicPoint;\n  } {\n    const dx1 = s1.x - s2.x;\n    const dy1 = s1.y - s2.y;\n    const dx2 = s2.x - s3.x;\n    const dy2 = s2.y - s3.y;\n\n    const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n    const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n\n    const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n    const dxm = m1.x - m2.x;\n    const dym = m1.y - m2.y;\n\n    const k = l2 / (l1 + l2);\n    const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n\n    const tx = s2.x - cm.x;\n    const ty = s2.y - cm.y;\n\n    return {\n      c1: new Point(m1.x + tx, m1.y + ty),\n      c2: new Point(m2.x + tx, m2.y + ty),\n    };\n  }\n\n  constructor(\n    public startPoint: Point,\n    public control2: BasicPoint,\n    public control1: BasicPoint,\n    public endPoint: Point,\n    public startWidth: number,\n    public endWidth: number,\n  ) {}\n\n  // Returns approximated length. Code taken from https://www.lemoda.net/maths/bezier-length/index.html.\n  public length(): number {\n    const steps = 10;\n    let length = 0;\n    let px;\n    let py;\n\n    for (let i = 0; i <= steps; i += 1) {\n      const t = i / steps;\n      const cx = this.point(\n        t,\n        this.startPoint.x,\n        this.control1.x,\n        this.control2.x,\n        this.endPoint.x,\n      );\n      const cy = this.point(\n        t,\n        this.startPoint.y,\n        this.control1.y,\n        this.control2.y,\n        this.endPoint.y,\n      );\n\n      if (i > 0) {\n        const xdiff = cx - (px as number);\n        const ydiff = cy - (py as number);\n\n        length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n      }\n\n      px = cx;\n      py = cy;\n    }\n\n    return length;\n  }\n\n  // Calculate parametric value of x or y given t and the four point coordinates of a cubic bezier curve.\n  private point(\n    t: number,\n    start: number,\n    c1: number,\n    c2: number,\n    end: number,\n  ): number {\n    // prettier-ignore\n    return (       start * (1.0 - t) * (1.0 - t)  * (1.0 - t))\n         + (3.0 *  c1    * (1.0 - t) * (1.0 - t)  * t)\n         + (3.0 *  c2    * (1.0 - t) * t          * t)\n         + (       end   * t         * t          * t);\n  }\n}\n","export class SignatureEventTarget {\n  /* tslint:disable: variable-name */\n  private _et: EventTarget;\n  /* tslint:enable: variable-name */\n\n  constructor() {\n    try {\n      this._et = new EventTarget();\n    } catch (error) {\n      // Using document as EventTarget to support iOS 13 and older.\n      // Because EventTarget constructor just exists at iOS 14 and later.\n      this._et = document;\n    }\n  }\n\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    this._et.addEventListener(type, listener, options);\n  }\n\n  dispatchEvent(event: Event): boolean {\n    return this._et.dispatchEvent(event);\n  }\n\n  removeEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: boolean | EventListenerOptions,\n  ): void {\n    this._et.removeEventListener(type, callback, options);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-this-alias */\n// Slightly simplified version of http://stackoverflow.com/a/27078401/815507\n\nexport function throttle(\n  fn: (...args: any[]) => any,\n  wait = 250,\n): (this: any, ...args: any[]) => any {\n  let previous = 0;\n  let timeout: number | null = null;\n  let result: any;\n  let storedContext: any;\n  let storedArgs: any[];\n\n  const later = (): void => {\n    previous = Date.now();\n    timeout = null;\n    result = fn.apply(storedContext, storedArgs);\n\n    if (!timeout) {\n      storedContext = null;\n      storedArgs = [];\n    }\n  };\n\n  return function wrapper(this: any, ...args: any[]): any {\n    const now = Date.now();\n    const remaining = wait - (now - previous);\n\n    storedContext = this;\n    storedArgs = args;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      previous = now;\n      result = fn.apply(storedContext, storedArgs);\n\n      if (!timeout) {\n        storedContext = null;\n        storedArgs = [];\n      }\n    } else if (!timeout) {\n      timeout = window.setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n","/**\n * The main idea and some parts of the code (e.g. drawing variable width Bézier curve) are taken from:\n * http://corner.squareup.com/2012/07/smoother-signatures.html\n *\n * Implementation of interpolation using cubic Bézier curves is taken from:\n * https://web.archive.org/web/20160323213433/http://www.benknowscode.com/2012/09/path-interpolation-using-cubic-bezier_9742.html\n *\n * Algorithm for approximated length of a Bézier curve is taken from:\n * http://www.lemoda.net/maths/bezier-length/index.html\n */\n\nimport { Bezier } from './bezier';\nimport { BasicPoint, Point } from './point';\nimport { SignatureEventTarget } from './signature_event_target';\nimport { throttle } from './throttle';\n\ndeclare global {\n  interface CSSStyleDeclaration {\n    msTouchAction: string | null;\n  }\n}\n\nexport type SignatureEvent = MouseEvent | Touch | PointerEvent;\n\nexport interface FromDataOptions {\n  clear?: boolean;\n}\n\nexport interface ToSVGOptions {\n  includeBackgroundColor?: boolean;\n}\n\nexport interface PointGroupOptions {\n  dotSize: number;\n  minWidth: number;\n  maxWidth: number;\n  penColor: string;\n  velocityFilterWeight: number;\n}\n\nexport interface Options extends Partial<PointGroupOptions> {\n  minDistance?: number;\n  backgroundColor?: string;\n  throttle?: number;\n}\n\nexport interface PointGroup extends PointGroupOptions {\n  points: BasicPoint[];\n}\n\nexport default class SignaturePad extends SignatureEventTarget {\n  // Public stuff\n  public dotSize: number;\n  public minWidth: number;\n  public maxWidth: number;\n  public penColor: string;\n  public minDistance: number;\n  public velocityFilterWeight: number;\n  public backgroundColor: string;\n  public throttle: number;\n\n  // Private stuff\n  /* tslint:disable: variable-name */\n  private _ctx: CanvasRenderingContext2D;\n  private _drawningStroke: boolean;\n  private _isEmpty: boolean;\n  private _lastPoints: Point[]; // Stores up to 4 most recent points; used to generate a new curve\n  private _data: PointGroup[]; // Stores all points in groups (one group per line or dot)\n  private _lastVelocity: number;\n  private _lastWidth: number;\n  private _strokeMoveUpdate: (event: SignatureEvent) => void;\n  /* tslint:enable: variable-name */\n\n  constructor(private canvas: HTMLCanvasElement, options: Options = {}) {\n    super();\n    this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n    this.minWidth = options.minWidth || 0.5;\n    this.maxWidth = options.maxWidth || 2.5;\n    this.throttle = ('throttle' in options ? options.throttle : 16) as number; // in milisecondss\n    this.minDistance = (\n      'minDistance' in options ? options.minDistance : 5\n    ) as number; // in pixels\n    this.dotSize = options.dotSize || 0;\n    this.penColor = options.penColor || 'black';\n    this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n\n    this._strokeMoveUpdate = this.throttle\n      ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)\n      : SignaturePad.prototype._strokeUpdate;\n    this._ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n\n    this.clear();\n\n    // Enable mouse and touch event handlers\n    this.on();\n  }\n\n  public clear(): void {\n    const { _ctx: ctx, canvas } = this;\n\n    // Clear canvas using background color\n    ctx.fillStyle = this.backgroundColor;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    this._data = [];\n    this._reset(this._getPointGroupOptions());\n    this._isEmpty = true;\n  }\n\n  public fromDataURL(\n    dataUrl: string,\n    options: {\n      ratio?: number;\n      width?: number;\n      height?: number;\n      xOffset?: number;\n      yOffset?: number;\n    } = {},\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const image = new Image();\n      const ratio = options.ratio || window.devicePixelRatio || 1;\n      const width = options.width || this.canvas.width / ratio;\n      const height = options.height || this.canvas.height / ratio;\n      const xOffset = options.xOffset || 0;\n      const yOffset = options.yOffset || 0;\n\n      this._reset(this._getPointGroupOptions());\n\n      image.onload = (): void => {\n        this._ctx.drawImage(image, xOffset, yOffset, width, height);\n        resolve();\n      };\n      image.onerror = (error): void => {\n        reject(error);\n      };\n      image.crossOrigin = 'anonymous';\n      image.src = dataUrl;\n\n      this._isEmpty = false;\n    });\n  }\n\n  public toDataURL(\n    type: 'image/svg+xml',\n    encoderOptions?: ToSVGOptions,\n  ): string;\n  public toDataURL(type?: string, encoderOptions?: number): string;\n  public toDataURL(\n    type = 'image/png',\n    encoderOptions?: number | ToSVGOptions | undefined,\n  ): string {\n    switch (type) {\n      case 'image/svg+xml':\n        if (typeof encoderOptions !== 'object') {\n          encoderOptions = undefined;\n        }\n        return `data:image/svg+xml;base64,${btoa(\n          this.toSVG(encoderOptions as ToSVGOptions),\n        )}`;\n      default:\n        if (typeof encoderOptions !== 'number') {\n          encoderOptions = undefined;\n        }\n        return this.canvas.toDataURL(type, encoderOptions);\n    }\n  }\n\n  public on(): void {\n    // Disable panning/zooming when touching canvas element\n    this.canvas.style.touchAction = 'none';\n    this.canvas.style.msTouchAction = 'none';\n    this.canvas.style.userSelect = 'none';\n\n    const isIOS =\n      /Macintosh/.test(navigator.userAgent) && 'ontouchstart' in document;\n\n    // The \"Scribble\" feature of iOS intercepts point events. So that we can lose some of them when tapping rapidly.\n    // Use touch events for iOS platforms to prevent it. See https://developer.apple.com/forums/thread/664108 for more information.\n    if (window.PointerEvent && !isIOS) {\n      this._handlePointerEvents();\n    } else {\n      this._handleMouseEvents();\n\n      if ('ontouchstart' in window) {\n        this._handleTouchEvents();\n      }\n    }\n  }\n\n  public off(): void {\n    // Enable panning/zooming when touching canvas element\n    this.canvas.style.touchAction = 'auto';\n    this.canvas.style.msTouchAction = 'auto';\n    this.canvas.style.userSelect = 'auto';\n\n    this.canvas.removeEventListener('pointerdown', this._handlePointerStart);\n    this.canvas.removeEventListener('pointermove', this._handlePointerMove);\n    this.canvas.ownerDocument.removeEventListener(\n      'pointerup',\n      this._handlePointerEnd,\n    );\n\n    this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n    this.canvas.removeEventListener('mousemove', this._handleMouseMove);\n    this.canvas.ownerDocument.removeEventListener(\n      'mouseup',\n      this._handleMouseUp,\n    );\n\n    this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n    this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n    this.canvas.removeEventListener('touchend', this._handleTouchEnd);\n  }\n\n  public isEmpty(): boolean {\n    return this._isEmpty;\n  }\n\n  public fromData(\n    pointGroups: PointGroup[],\n    { clear = true }: FromDataOptions = {},\n  ): void {\n    if (clear) {\n      this.clear();\n    }\n\n    this._fromData(\n      pointGroups,\n      this._drawCurve.bind(this),\n      this._drawDot.bind(this),\n    );\n\n    this._data = this._data.concat(pointGroups);\n  }\n\n  public toData(): PointGroup[] {\n    return this._data;\n  }\n\n  // Event handlers\n  private _handleMouseDown = (event: MouseEvent): void => {\n    if (event.buttons === 1) {\n      this._drawningStroke = true;\n      this._strokeBegin(event);\n    }\n  };\n\n  private _handleMouseMove = (event: MouseEvent): void => {\n    if (this._drawningStroke) {\n      this._strokeMoveUpdate(event);\n    }\n  };\n\n  private _handleMouseUp = (event: MouseEvent): void => {\n    if (event.buttons === 1 && this._drawningStroke) {\n      this._drawningStroke = false;\n      this._strokeEnd(event);\n    }\n  };\n\n  private _handleTouchStart = (event: TouchEvent): void => {\n    // Prevent scrolling.\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    if (event.targetTouches.length === 1) {\n      const touch = event.changedTouches[0];\n      this._strokeBegin(touch);\n    }\n  };\n\n  private _handleTouchMove = (event: TouchEvent): void => {\n    // Prevent scrolling.\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    const touch = event.targetTouches[0];\n    this._strokeMoveUpdate(touch);\n  };\n\n  private _handleTouchEnd = (event: TouchEvent): void => {\n    const wasCanvasTouched = event.target === this.canvas;\n    if (wasCanvasTouched) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      const touch = event.changedTouches[0];\n      this._strokeEnd(touch);\n    }\n  };\n\n  private _handlePointerStart = (event: PointerEvent): void => {\n    this._drawningStroke = true;\n    event.preventDefault();\n    this._strokeBegin(event);\n  };\n\n  private _handlePointerMove = (event: PointerEvent): void => {\n    if (this._drawningStroke) {\n      event.preventDefault();\n      this._strokeMoveUpdate(event);\n    }\n  };\n\n  private _handlePointerEnd = (event: PointerEvent): void => {\n    if (this._drawningStroke) {\n      event.preventDefault();\n      this._drawningStroke = false;\n      this._strokeEnd(event);\n    }\n  };\n\n  private _getPointGroupOptions(group?: PointGroup) {\n    return {\n      penColor: group && 'penColor' in group ? group.penColor : this.penColor,\n      dotSize: group && 'dotSize' in group ? group.dotSize : this.dotSize,\n      minWidth: group && 'minWidth' in group ? group.minWidth : this.minWidth,\n      maxWidth: group && 'maxWidth' in group ? group.maxWidth : this.maxWidth,\n      velocityFilterWeight:\n        group && 'velocityFilterWeight' in group\n          ? group.velocityFilterWeight\n          : this.velocityFilterWeight,\n    };\n  }\n\n  // Private methods\n  private _strokeBegin(event: SignatureEvent): void {\n    this.dispatchEvent(new CustomEvent('beginStroke', { detail: event }));\n\n    const pointGroupOptions = this._getPointGroupOptions();\n\n    const newPointGroup: PointGroup = {\n      ...pointGroupOptions,\n      points: [],\n    };\n\n    this._data.push(newPointGroup);\n    this._reset(pointGroupOptions);\n    this._strokeUpdate(event);\n  }\n\n  private _strokeUpdate(event: SignatureEvent): void {\n    if (this._data.length === 0) {\n      // This can happen if clear() was called while a signature is still in progress,\n      // or if there is a race condition between start/update events.\n      this._strokeBegin(event);\n      return;\n    }\n\n    this.dispatchEvent(\n      new CustomEvent('beforeUpdateStroke', { detail: event }),\n    );\n\n    const x = event.clientX;\n    const y = event.clientY;\n    const pressure =\n      (event as PointerEvent).pressure !== undefined\n        ? (event as PointerEvent).pressure\n        : (event as Touch).force !== undefined\n        ? (event as Touch).force\n        : 0;\n\n    const point = this._createPoint(x, y, pressure);\n    const lastPointGroup = this._data[this._data.length - 1];\n    const lastPoints = lastPointGroup.points;\n    const lastPoint =\n      lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n    const isLastPointTooClose = lastPoint\n      ? point.distanceTo(lastPoint) <= this.minDistance\n      : false;\n    const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);\n\n    // Skip this point if it's too close to the previous one\n    if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n      const curve = this._addPoint(point, pointGroupOptions);\n\n      if (!lastPoint) {\n        this._drawDot(point, pointGroupOptions);\n      } else if (curve) {\n        this._drawCurve(curve, pointGroupOptions);\n      }\n\n      lastPoints.push({\n        time: point.time,\n        x: point.x,\n        y: point.y,\n        pressure: point.pressure,\n      });\n    }\n\n    this.dispatchEvent(new CustomEvent('afterUpdateStroke', { detail: event }));\n  }\n\n  private _strokeEnd(event: SignatureEvent): void {\n    this._strokeUpdate(event);\n\n    this.dispatchEvent(new CustomEvent('endStroke', { detail: event }));\n  }\n\n  private _handlePointerEvents(): void {\n    this._drawningStroke = false;\n\n    this.canvas.addEventListener('pointerdown', this._handlePointerStart);\n    this.canvas.addEventListener('pointermove', this._handlePointerMove);\n    this.canvas.ownerDocument.addEventListener(\n      'pointerup',\n      this._handlePointerEnd,\n    );\n  }\n\n  private _handleMouseEvents(): void {\n    this._drawningStroke = false;\n\n    this.canvas.addEventListener('mousedown', this._handleMouseDown);\n    this.canvas.addEventListener('mousemove', this._handleMouseMove);\n    this.canvas.ownerDocument.addEventListener('mouseup', this._handleMouseUp);\n  }\n\n  private _handleTouchEvents(): void {\n    this.canvas.addEventListener('touchstart', this._handleTouchStart);\n    this.canvas.addEventListener('touchmove', this._handleTouchMove);\n    this.canvas.addEventListener('touchend', this._handleTouchEnd);\n  }\n\n  // Called when a new line is started\n  private _reset(options: PointGroupOptions): void {\n    this._lastPoints = [];\n    this._lastVelocity = 0;\n    this._lastWidth = (options.minWidth + options.maxWidth) / 2;\n    this._ctx.fillStyle = options.penColor;\n  }\n\n  private _createPoint(x: number, y: number, pressure: number): Point {\n    const rect = this.canvas.getBoundingClientRect();\n\n    return new Point(\n      x - rect.left,\n      y - rect.top,\n      pressure,\n      new Date().getTime(),\n    );\n  }\n\n  // Add point to _lastPoints array and generate a new curve if there are enough points (i.e. 3)\n  private _addPoint(point: Point, options: PointGroupOptions): Bezier | null {\n    const { _lastPoints } = this;\n\n    _lastPoints.push(point);\n\n    if (_lastPoints.length > 2) {\n      // To reduce the initial lag make it work with 3 points\n      // by copying the first point to the beginning.\n      if (_lastPoints.length === 3) {\n        _lastPoints.unshift(_lastPoints[0]);\n      }\n\n      // _points array will always have 4 points here.\n      const widths = this._calculateCurveWidths(\n        _lastPoints[1],\n        _lastPoints[2],\n        options,\n      );\n      const curve = Bezier.fromPoints(_lastPoints, widths);\n\n      // Remove the first element from the list, so that there are no more than 4 points at any time.\n      _lastPoints.shift();\n\n      return curve;\n    }\n\n    return null;\n  }\n\n  private _calculateCurveWidths(\n    startPoint: Point,\n    endPoint: Point,\n    options: PointGroupOptions,\n  ): { start: number; end: number } {\n    const velocity =\n      options.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n      (1 - options.velocityFilterWeight) * this._lastVelocity;\n\n    const newWidth = this._strokeWidth(velocity, options);\n\n    const widths = {\n      end: newWidth,\n      start: this._lastWidth,\n    };\n\n    this._lastVelocity = velocity;\n    this._lastWidth = newWidth;\n\n    return widths;\n  }\n\n  private _strokeWidth(velocity: number, options: PointGroupOptions): number {\n    return Math.max(options.maxWidth / (velocity + 1), options.minWidth);\n  }\n\n  private _drawCurveSegment(x: number, y: number, width: number): void {\n    const ctx = this._ctx;\n\n    ctx.moveTo(x, y);\n    ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n    this._isEmpty = false;\n  }\n\n  private _drawCurve(curve: Bezier, options: PointGroupOptions): void {\n    const ctx = this._ctx;\n    const widthDelta = curve.endWidth - curve.startWidth;\n    // '2' is just an arbitrary number here. If only length is used, then\n    // there are gaps between curve segments :/\n    const drawSteps = Math.ceil(curve.length()) * 2;\n\n    ctx.beginPath();\n    ctx.fillStyle = options.penColor;\n\n    for (let i = 0; i < drawSteps; i += 1) {\n      // Calculate the Bezier (x, y) coordinate for this step.\n      const t = i / drawSteps;\n      const tt = t * t;\n      const ttt = tt * t;\n      const u = 1 - t;\n      const uu = u * u;\n      const uuu = uu * u;\n\n      let x = uuu * curve.startPoint.x;\n      x += 3 * uu * t * curve.control1.x;\n      x += 3 * u * tt * curve.control2.x;\n      x += ttt * curve.endPoint.x;\n\n      let y = uuu * curve.startPoint.y;\n      y += 3 * uu * t * curve.control1.y;\n      y += 3 * u * tt * curve.control2.y;\n      y += ttt * curve.endPoint.y;\n\n      const width = Math.min(\n        curve.startWidth + ttt * widthDelta,\n        options.maxWidth,\n      );\n      this._drawCurveSegment(x, y, width);\n    }\n\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private _drawDot(point: BasicPoint, options: PointGroupOptions): void {\n    const ctx = this._ctx;\n    const width =\n      options.dotSize > 0\n        ? options.dotSize\n        : (options.minWidth + options.maxWidth) / 2;\n\n    ctx.beginPath();\n    this._drawCurveSegment(point.x, point.y, width);\n    ctx.closePath();\n    ctx.fillStyle = options.penColor;\n    ctx.fill();\n  }\n\n  private _fromData(\n    pointGroups: PointGroup[],\n    drawCurve: SignaturePad['_drawCurve'],\n    drawDot: SignaturePad['_drawDot'],\n  ): void {\n    for (const group of pointGroups) {\n      const { points } = group;\n      const pointGroupOptions = this._getPointGroupOptions(group);\n\n      if (points.length > 1) {\n        for (let j = 0; j < points.length; j += 1) {\n          const basicPoint = points[j];\n          const point = new Point(\n            basicPoint.x,\n            basicPoint.y,\n            basicPoint.pressure,\n            basicPoint.time,\n          );\n\n          if (j === 0) {\n            this._reset(pointGroupOptions);\n          }\n\n          const curve = this._addPoint(point, pointGroupOptions);\n\n          if (curve) {\n            drawCurve(curve, pointGroupOptions);\n          }\n        }\n      } else {\n        this._reset(pointGroupOptions);\n\n        drawDot(points[0], pointGroupOptions);\n      }\n    }\n  }\n\n  public toSVG({ includeBackgroundColor = false }: ToSVGOptions = {}): string {\n    const pointGroups = this._data;\n    const ratio = Math.max(window.devicePixelRatio || 1, 1);\n    const minX = 0;\n    const minY = 0;\n    const maxX = this.canvas.width / ratio;\n    const maxY = this.canvas.height / ratio;\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    svg.setAttribute('viewBox', `${minX} ${minY} ${maxX} ${maxY}`);\n    svg.setAttribute('width', maxX.toString());\n    svg.setAttribute('height', maxY.toString());\n\n    if (includeBackgroundColor && this.backgroundColor) {\n      const rect = document.createElement('rect');\n      rect.setAttribute('width', '100%');\n      rect.setAttribute('height', '100%');\n      rect.setAttribute('fill', this.backgroundColor);\n\n      svg.appendChild(rect);\n    }\n\n    this._fromData(\n      pointGroups,\n\n      (curve, { penColor }) => {\n        const path = document.createElement('path');\n\n        // Need to check curve for NaN values, these pop up when drawing\n        // lines on the canvas that are not continuous. E.g. Sharp corners\n        // or stopping mid-stroke and than continuing without lifting mouse.\n        /* eslint-disable no-restricted-globals */\n        if (\n          !isNaN(curve.control1.x) &&\n          !isNaN(curve.control1.y) &&\n          !isNaN(curve.control2.x) &&\n          !isNaN(curve.control2.y)\n        ) {\n          const attr =\n            `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(\n              3,\n            )} ` +\n            `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +\n            `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +\n            `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n          path.setAttribute('d', attr);\n          path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n          path.setAttribute('stroke', penColor);\n          path.setAttribute('fill', 'none');\n          path.setAttribute('stroke-linecap', 'round');\n\n          svg.appendChild(path);\n        }\n        /* eslint-enable no-restricted-globals */\n      },\n\n      (point, { penColor, dotSize, minWidth, maxWidth }) => {\n        const circle = document.createElement('circle');\n        const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;\n        circle.setAttribute('r', size.toString());\n        circle.setAttribute('cx', point.x.toString());\n        circle.setAttribute('cy', point.y.toString());\n        circle.setAttribute('fill', penColor);\n\n        svg.appendChild(circle);\n      },\n    );\n\n    return svg.outerHTML;\n  }\n}\n"],"names":[],"version":3,"file":"signature_pad.init.js.map"}